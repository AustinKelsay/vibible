"use node";

import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";
import crypto from "crypto";

/**
 * Public action to upgrade a session to admin tier.
 * Validates an HMAC token (never receives the raw secret) before calling the internal mutation.
 * This allows API routes to call admin upgrade while keeping it secure.
 *
 * The API route generates: HMAC-SHA256(secret, "admin-upgrade:{timestamp}:{sid}")
 * This action regenerates the same HMAC and compares.
 *
 * @param sid - Session ID to upgrade
 * @param timestamp - Unix timestamp when token was generated (for replay protection)
 * @param authToken - HMAC token generated by the API route
 * @throws Error if token is invalid, expired, or session is not found
 */
export const upgradeToAdmin = action({
  args: {
    sid: v.string(),
    timestamp: v.string(),
    authToken: v.string(),
  },
  handler: async (ctx, args) => {
    const secret = process.env.ADMIN_PASSWORD_SECRET;

    if (!secret) {
      throw new Error("Admin access not configured");
    }

    // Validate timestamp is within 5 minutes (replay protection)
    const tokenTime = parseInt(args.timestamp, 10);
    const now = Date.now();
    const fiveMinutes = 5 * 60 * 1000;

    if (isNaN(tokenTime) || Math.abs(now - tokenTime) > fiveMinutes) {
      throw new Error("Token expired");
    }

    // Generate expected HMAC and compare
    const expectedToken = crypto
      .createHmac("sha256", secret)
      .update(`admin-upgrade:${args.timestamp}:${args.sid}`)
      .digest("hex");

    // Validate that authToken is a valid hex string before creating buffers
    // Hex strings must contain only 0-9, a-f, A-F and have even length
    if (
      !args.authToken ||
      args.authToken.length === 0 ||
      args.authToken.length % 2 !== 0 ||
      !/^[0-9a-fA-F]+$/.test(args.authToken)
    ) {
      throw new Error("Unauthorized");
    }

    // Create buffers with error handling - treat invalid hex as auth failure
    let tokenBuffer: Buffer;
    let expectedBuffer: Buffer;
    try {
      tokenBuffer = Buffer.from(args.authToken, "hex");
      expectedBuffer = Buffer.from(expectedToken, "hex");
    } catch {
      throw new Error("Unauthorized");
    }

    // Ensure both buffers were successfully created and have equal length
    // Only then perform timing-safe comparison
    if (
      !tokenBuffer ||
      !expectedBuffer ||
      tokenBuffer.length === 0 ||
      expectedBuffer.length === 0 ||
      tokenBuffer.length !== expectedBuffer.length ||
      !crypto.timingSafeEqual(tokenBuffer, expectedBuffer)
    ) {
      throw new Error("Unauthorized");
    }

    await ctx.runMutation(internal.sessions.upgradeToAdminInternal, {
      sid: args.sid,
    });

    return { success: true };
  },
});
